## Useful links
  - https://developers.google.com/protocol-buffers
  - https://developers.google.com/protocol-buffers/docs/pythontutorial


## What are protocol buffers?
Protocol buffers provide a language-neutral, platform-neutral, extensible mechanism for serializing structured data in a forward-compatible and backward-compatible way. It’s like JSON, except it's smaller and faster, and it generates native language bindings.

Protocol buffers are a combination of
- definition language (created in .proto files)
- the code that the proto compiler generates to interface with data
- language-specific runtime libraries
- the serialization format for data that is written to a file (or sent across a network connection)


## What Problems do Protocol Buffers Solve?
- Protocol buffers provide a serialization format for packets of typed, structured data that are up to a few megabytes in size. 
- The format is suitable for both ephemeral network traffic and long-term data storage.
- Protocol buffers can be extended with new information without invalidating existing data or requiring code to be updated.
- Protocol buffers are the most commonly-used data format at Google: they are used extensively in inter-server communications as well as for archival storage of data on disk. 

## How does it work?
Protocol buffer messages and services are described by engineer-authored **.proto** files.
``` 
 message Person {
  optional string name = 1;
  optional int32 id = 2;
  optional string email = 3;
}
```
The proto compiler is invoked at build time on **.proto** files to generate code in various programming languages to manipulate the corresponding protocol buffer. Each generated class contains simple accessors for each field and methods to serialize and parse the whole structure to and from raw bytes. The following shows you an example that uses those generated methods (in Java):
```
Person john = Person.newBuilder()
    .setId(1234)
    .setName("John Doe")
    .setEmail("jdoe@example.com")
    .build();
output = new FileOutputStream(args[0]);
john.writeTo(output);
```
The code generated by protocol buffers provides utility methods to retrieve data from files and streams, extract individual values from the data, check if data exists, serialize data back to a file or stream, and other useful functions.

You can then deserialize data using the methods protocol buffers creates in other languages, like C++:
```
Person john;
fstream input(argv[1], ios::in | ios::binary);
john.ParseFromIstream(&input);
int id = john.id();
std::string name = john.name();
std::string email = john.email();
```

## Protocol Buffers Definition Syntax
When defining **.proto** files, you can specify that a field is either **optional** or **repeated** (proto2 and proto3) or **singular** (proto3). 

After setting the optionality/repeatability of a field, you specify the data type. Protocol buffers support the usual primitive data types, such as integers, booleans, and floats. Additionally: 
-  **Duration** is a signed, fixed-length span of time, such as 42s.
- **Timestamp** is a point in time independent of any time zone or calendar, such as 2017-01-15T01:30:15.01Z.
- **Interval** is a time interval independent of time zone or calendar, such as 2017-01-15T01:30:15.01Z - 2017-01-16T02:30:15.01Z.
- **Date** is a whole calendar date, such as 2025-09-19.
- **DayOfWeek** is a day of the week, such as Monday.
- **TimeOfDay** is a time of day, such as 10:42:23.
- **LatLng** is a latitude/longitude pair, such as 37.386051 latitude and -122.083855 longitude.
- **Money** is an amount of money with its currency type, such as 42 USD.
- **PostalAddress** is a postal address, such as 1600 Amphitheatre Parkway Mountain View, CA 94043 USA.
- **Color** is a color in the RGBA color space.
- **Month** is a month of the year, such as April.


A field can also be of:
- A **message** type, so that you can nest parts of the definition, such as for repeating sets of data.
- An **enum** type, so you can specify a set of values to choose from.
- A **oneof** type, which you can use when a message has many optional fields and at most one field will be set at the same time.
- A **map** type, to add key-value pairs to your definition.
After setting optionality and field type, you assign a field number. Field numbers cannot be repurposed or reused. If you delete a field, you should reserve its field number to prevent someone from accidentally reusing the number.


## Python Tutorial
By walking through creating a simple example application, it shows you how to
- Define message formats in a .proto file.
- Use the protocol buffer compiler.
- Use the Python protocol buffer API to write and read messages.

### Defining Your Protocol Format
Example: here is the **.proto** file that defines your messages, **addressbook.proto**.
```
syntax = "proto2";

package tutorial;

message Person {
  optional string name = 1;
  optional int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    optional string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phones = 4;
}

message AddressBook {
  repeated Person people = 1;
}
```
The **.proto** file starts with a package declaration, which helps to prevent naming conflicts between different projects. In Python, packages are normally determined by directory structure, so the **package** you define in your **.proto** file will have no effect on the generated code. However, you should still declare one to avoid name collisions in the Protocol Buffers name space as well as in non-Python languages.

Next, you have your message definitions. A message is just an aggregate containing a set of typed fields. Many standard simple data types are available as field types, including **bool**, **int32**, **float**, **double**, and **string**. You can also add further structure to your messages by using other message types as field types – in the above example the Person message contains **PhoneNumber** messages, while the **AddressBook** message contains **Person** messages. You can even define message types nested inside other messages – as you can see, the **PhoneNumber** type is defined inside **Person**. You can also define **enum** types if you want one of your fields to have one of a predefined list of values – here you want to specify that a phone number can be one of the following phone types: **MOBILE**, **HOME**, or **WORK**.

The " = 1", " = 2" markers on each element identify the unique "tag" that field uses in the binary encoding. Tag numbers 1-15 require one less byte to encode than higher numbers, so as an optimization you can decide to use those tags for the commonly used or repeated elements, leaving tags 16 and higher for less-commonly used optional elements. Each element in a repeated field requires re-encoding the tag number, so repeated fields are particularly good candidates for this optimization.

Each field must be annotated with one of the following modifiers:
- **optional**: the field may or may not be set. If an optional field value isn't set, a default value is used. For simple types, you can specify your own default value, as we've done for the phone number type in the example. Otherwise, a system default is used: zero for numeric types, the empty string for strings, false for bools. For embedded messages, the default value is always the "default instance" or "prototype" of the message, which has none of its fields set. Calling the accessor to get the value of an optional (or required) field which has not been explicitly set always returns that field's default value.
- **repeated**: the field may be repeated any number of times (including zero). The order of the repeated values will be preserved in the protocol buffer. Think of repeated fields as dynamically sized arrays.
- **required**: a value for the field must be provided, otherwise the message will be considered "uninitialized". Serializing an uninitialized message will raise an exception. Parsing an uninitialized message will fail. Other than this, a required field behaves exactly like an optional field.

### Compiling Your Protocol Buffers
Now that you have a **.proto**, the next thing you need to do is generate the classes you'll need to read and write **AddressBook** (and hence **Person** and **PhoneNumber**) messages. To do this, you need to run the protocol buffer compiler **protoc** on your **.proto**:
- If you haven't installed the compiler, [download](https://developers.google.com/protocol-buffers/docs/downloads) the package and follow the instructions in the README.
- Now run the compiler, specifying the source directory (where your application's source code lives – the current directory is used if you don't provide a value), the destination directory (where you want the generated code to go; often the same as $SRC_DIR), and the path to your .proto. In this case, you...:
```protoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/addressbook.proto```
This generates addressbook_pb2.py in your specified destination directory.


### The Protocol Buffer API
Unlike when you generate Java and C++ protocol buffer code, the Python protocol buffer compiler doesn't generate your data access code for you directly. Instead (as you'll see if you look at addressbook_pb2.py) it generates special descriptors for all your messages, enums, and fields, and some mysteriously empty classes, one for each message type:
```
class Person(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType

  class PhoneNumber(message.Message):
    __metaclass__ = reflection.GeneratedProtocolMessageType
    DESCRIPTOR = _PERSON_PHONENUMBER
  DESCRIPTOR = _PERSON

class AddressBook(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _ADDRESSBOOK
```
The important line in each class is **__metaclass__ = reflection.GeneratedProtocolMessageType**. While the details of how Python metaclasses work is beyond the scope of this tutorial, you can think of them as like a template for creating classes. At load time, the **GeneratedProtocolMessageType** metaclass uses the specified descriptors to create all the Python methods you need to work with each message type and adds them to the relevant classes. You can then use the fully-populated classes in your code.

The end effect of all this is that you can use the **Person** class as if it defined each field of the **Message** base class as a regular field. For example, you could write:
```
import addressbook_pb2
person = addressbook_pb2.Person()
person.id = 1234
person.name = "John Doe"
person.email = "jdoe@example.com"
phone = person.phones.add()
phone.number = "555-4321"
phone.type = addressbook_pb2.Person.HOME
```

#### Standard Message Methods
Each message class also contains a number of other methods that let you check or manipulate the entire message, including:

- **IsInitialized()**: checks if all the required fields have been set.
- **__str__()**: returns a human-readable representation of the message, particularly useful for debugging. (Usually invoked as **str(message)** or **print message**.)
- **CopyFrom(other_msg)**: overwrites the message with the given message's values.
- **Clear()**: clears all the elements back to the empty state.

#### Parsing and Serialization
Finally, each protocol buffer class has methods for writing and reading messages of your chosen type using the protocol buffer binary format. These include:

- **SerializeToString()**: serializes the message and returns it as a string. Note that the bytes are binary, not text; we only use the str type as a convenient container.
- **ParseFromString(data)**: parses a message from the given string.

### Writing A Message
Here is a program which reads an AddressBook from a file, adds one new Person to it based on user input, and writes the new AddressBook back out to the file again. 
``` Python
#! /usr/bin/python

import addressbook_pb2
import sys

# This function fills in a Person message based on user input.
def PromptForAddress(person):
  person.id = int(raw_input("Enter person ID number: "))
  person.name = raw_input("Enter name: ")

  email = raw_input("Enter email address (blank for none): ")
  if email != "":
    person.email = email

  while True:
    number = raw_input("Enter a phone number (or leave blank to finish): ")
    if number == "":
      break

    phone_number = person.phones.add()
    phone_number.number = number

    type = raw_input("Is this a mobile, home, or work phone? ")
    if type == "mobile":
      phone_number.type = addressbook_pb2.Person.PhoneType.MOBILE
    elif type == "home":
      phone_number.type = addressbook_pb2.Person.PhoneType.HOME
    elif type == "work":
      phone_number.type = addressbook_pb2.Person.PhoneType.WORK
    else:
      print "Unknown phone type; leaving as default value."

# Main procedure:  Reads the entire address book from a file,
#   adds one person based on user input, then writes it back out to the same
#   file.
if len(sys.argv) != 2:
  print "Usage:", sys.argv[0], "ADDRESS_BOOK_FILE"
  sys.exit(-1)

address_book = addressbook_pb2.AddressBook()

# Read the existing address book.
try:
  f = open(sys.argv[1], "rb")
  address_book.ParseFromString(f.read())
  f.close()
except IOError:
  print sys.argv[1] + ": Could not open file.  Creating a new one."

# Add an address.
PromptForAddress(address_book.people.add())

# Write the new address book back to disk.
f = open(sys.argv[1], "wb")
f.write(address_book.SerializeToString())
f.close()
```

### Reading A Message
This example reads the file created by the above example and prints all the information in it.
``` Python
#! /usr/bin/python

import addressbook_pb2
import sys

# Iterates though all people in the AddressBook and prints info about them.
def ListPeople(address_book):
  for person in address_book.people:
    print "Person ID:", person.id
    print "  Name:", person.name
    if person.HasField('email'):
      print "  E-mail address:", person.email

    for phone_number in person.phones:
      if phone_number.type == addressbook_pb2.Person.PhoneType.MOBILE:
        print "  Mobile phone #: ",
      elif phone_number.type == addressbook_pb2.Person.PhoneType.HOME:
        print "  Home phone #: ",
      elif phone_number.type == addressbook_pb2.Person.PhoneType.WORK:
        print "  Work phone #: ",
      print phone_number.number

# Main procedure:  Reads the entire address book from a file and prints all
#   the information inside.
if len(sys.argv) != 2:
  print "Usage:", sys.argv[0], "ADDRESS_BOOK_FILE"
  sys.exit(-1)

address_book = addressbook_pb2.AddressBook()

# Read the existing address book.
f = open(sys.argv[1], "rb")
address_book.ParseFromString(f.read())
f.close()

ListPeople(address_book)
```